#!/usr/bin/env python3
"""
S.A.R Launcher - Script de inicio para Smart Anime Recommender
-----------------------------------------------------------------
Este launcher ofrece un men√∫ simplificado con tres opciones:

1. Iniciar sistema con bases de datos vac√≠as
   - Inicia contenedores Docker de PostgreSQL
   - Crea bases de datos vac√≠as listas para ser usadas
   - Inicia el backend FastAPI y el frontend React

2. Iniciar sistema con datos precargados desde backup
   - Inicia contenedores Docker de PostgreSQL
   - Restaura los datos desde los archivos de backup
   - Inicia el backend FastAPI y el frontend React

3. Salir
   - Termina el programa sin iniciar nada

Requisitos:
- Docker Desktop debe estar en ejecuci√≥n
- Los archivos del modelo de IA deben existir en /model
- Archivos de backup (opcional) en /backend/data/backup

Autor: Smart Anime Recommender Team
√öltima actualizaci√≥n: 2024
"""

import os
import subprocess
import sys
import time
import signal
import json
import tempfile
import threading
import atexit
from pathlib import Path

# Control para evitar terminaci√≥n m√∫ltiple
is_terminating = threading.Event()

def check_docker_running():
    """Verifica si Docker est√° ejecut√°ndose"""
    try:
        subprocess.run(
            ["powershell.exe", "docker info"],
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            check=True
        )
        return True
    except subprocess.CalledProcessError:
        return False

def start_docker_containers():
    """Inicia los contenedores Docker necesarios para la aplicaci√≥n"""
    print("üîÑ Verificando entorno Docker...")
    
    # Rutas a los archivos docker-compose.yml
    db_main_path = Path(__file__).parent / "backend" / "data" / "database"
    db_embeddings_path = Path(__file__).parent / "backend" / "data" / "databaseForEmbeddings"
    
    # Verificar existencia de archivos docker-compose.yml
    if not (db_main_path / "docker-compose.yml").exists():
        print("‚ùå Error: No se encontr√≥ docker-compose.yml para base de datos principal")
        return False
        
    if not (db_embeddings_path / "docker-compose.yml").exists():
        print("‚ùå Error: No se encontr√≥ docker-compose.yml para base de datos de embeddings")
        return False
    
    # Verificar si Docker est√° en ejecuci√≥n
    if not check_docker_running():
        print("\n‚ùå Error: Docker no est√° en ejecuci√≥n.")
        print("‚ÑπÔ∏è Por favor, inicie Docker Desktop y vuelva a intentarlo.")
        return False
    
    # Verificar si existen los vol√∫menes de backup montados en los archivos docker-compose.yml
    backup_dir = Path(__file__).parent / "backend" / "data" / "backup"
    if not backup_dir.exists():
        print(f"‚ö†Ô∏è Advertencia: No se encontr√≥ la carpeta de backups: {backup_dir}")
        print("‚ÑπÔ∏è La restauraci√≥n desde backup podr√≠a no funcionar correctamente.")
        
        # Crear directorio de backup si no existe
        try:
            backup_dir.mkdir(parents=True, exist_ok=True)
            print("‚úÖ Se ha creado el directorio de backup.")
        except Exception as e:
            print(f"‚ùå Error al crear el directorio de backup: {e}")
    
    # Detener contenedores activos para asegurar un estado limpio
    print("\nüîÑ Preparando entorno Docker limpio...")
    try:
        # Detener contenedores espec√≠ficos por nombre en lugar de usar docker-compose
        subprocess.run(
            ["powershell.exe", "docker stop anime_postgres anime_postgres_embeddings 2>$null"],
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        subprocess.run(
            ["powershell.exe", "docker rm anime_postgres anime_postgres_embeddings 2>$null"],
            shell=True,
            stdout=subprocess.DEVNULL,
            stderr=subprocess.DEVNULL
        )
        print("‚úì Contenedores anteriores detenidos y eliminados")
    except Exception:
        pass  # Ignorar errores si los contenedores no exist√≠an

    # Iniciar base de datos principal
    print("\nüîÑ Iniciando contenedor de base de datos principal...")
    try:
        result = subprocess.run(
            ["powershell.exe", "docker-compose up -d"],
            cwd=db_main_path,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"‚ùå Error al iniciar base de datos principal:")
            print(result.stderr.strip())
            return False
            
        print("‚úÖ Base de datos principal iniciada")
        
        # Esperar a que PostgreSQL est√© listo - verificaci√≥n activa
        print("‚è≥ Esperando a que la base de datos principal est√© lista...")
        for i in range(20):  # Intentar por 20 segundos
            time.sleep(1)
            check = subprocess.run(
                ["powershell.exe", 'docker exec -i anime_postgres pg_isready -h localhost -U anime_db 2>$null'],
                capture_output=True,
                text=True
            )
            if check.returncode == 0:
                print("‚úÖ Base de datos principal lista para conexiones")
                break
                
            # Al final del bucle, mostrar progreso
            if i == 19:
                print("‚ö†Ô∏è Tiempo de espera agotado, continuando de todas formas...")
    except Exception as e:
        print(f"‚ùå Error al iniciar base de datos principal: {e}")
        return False

    # Iniciar base de datos de embeddings
    print("\nüîÑ Iniciando contenedor de base de datos de embeddings...")
    try:
        result = subprocess.run(
            ["powershell.exe", "docker-compose up -d"],
            cwd=db_embeddings_path,
            capture_output=True,
            text=True
        )
        
        if result.returncode != 0:
            print(f"‚ùå Error al iniciar base de datos de embeddings:")
            print(result.stderr.strip())
            return False
            
        print("‚úÖ Base de datos de embeddings iniciada")
        
        # Esperar a que PostgreSQL est√© listo - verificaci√≥n activa
        print("‚è≥ Esperando a que la base de datos de embeddings est√© lista...")
        for i in range(20):  # Intentar por 20 segundos
            time.sleep(1)
            check = subprocess.run(
                ["powershell.exe", 'docker exec -i anime_postgres_embeddings pg_isready -h localhost -U anime_db 2>$null'],
                capture_output=True,
                text=True
            )
            if check.returncode == 0:
                print("‚úÖ Base de datos de embeddings lista para conexiones")
                break
                
            # Al final del bucle, mostrar progreso
            if i == 19:
                print("‚ö†Ô∏è Tiempo de espera agotado, continuando de todas formas...")
    except Exception as e:
        print(f"‚ùå Error al iniciar base de datos de embeddings: {e}")
        return False
    
    # Finalizaci√≥n y verificaci√≥n final de disponibilidad
    print("\n‚úÖ Contenedores Docker iniciados correctamente")
    return True

def start_backend():
    """Inicia el backend con FastAPI"""
    print("üîÑ Iniciando backend...")
    
    # Rutas y configuraci√≥n
    backend_dir = Path(__file__).parent / "backend" / "API"
    venv_python = Path(__file__).parent / ".venv311" / "Scripts" / "python.exe"
    
    # Verificar entorno virtual
    if not venv_python.exists():
        print("‚ùå Error: No se encontr√≥ el entorno virtual")
        return None
    
    # Iniciar proceso
    backend_process = subprocess.Popen(
        [venv_python, "-m", "uvicorn", "main:app", "--reload", "--host", "127.0.0.1", "--port", "8000"],
        cwd=backend_dir,
        creationflags=subprocess.CREATE_NEW_CONSOLE
    )
    
    print("‚úÖ Backend iniciado (http://127.0.0.1:8000)")
    time.sleep(2)
    return backend_process

def start_frontend():
    """Inicia el frontend con Vite"""
    print("üîÑ Iniciando frontend...")
    
    # Ruta y verificaci√≥n
    frontend_dir = Path(__file__).parent / "frontend"
    if not (frontend_dir / "package.json").exists():
        print("‚ùå Error: No se encontr√≥ package.json")
        return None
    
    # Iniciar proceso
    frontend_process = subprocess.Popen(
        ["powershell.exe", "-Command", "npm run dev"],
        cwd=frontend_dir,
        creationflags=subprocess.CREATE_NEW_CONSOLE
    )
    
    print("‚úÖ Frontend iniciado (http://localhost:5173)")
    time.sleep(3)
    return frontend_process

def terminate_processes(processes):
    """Termina todos los procesos iniciados"""
    if is_terminating.is_set():
        return
    
    is_terminating.set()
    print("\nDeteniendo el sistema...")
    
    for name, process in processes.items():
        if process:
            try:
                print(f"Terminando {name} (PID: {process.pid})...")
                subprocess.run(['taskkill', '/F', '/T', '/PID', str(process.pid)], 
                              stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            except Exception as e:
                print(f"Error: {e}")
    
    print("‚úÖ Sistema detenido")

def restore_databases_from_backup():
    """Restaura las bases de datos desde los archivos de backup"""
    print("\nüîÑ Restaurando bases de datos desde los archivos de backup...")
    
    try:
        # Verificar si existen los archivos de backup
        backup_main = Path(__file__).parent / "backend" / "data" / "backup" / "animeDB.sql"
        backup_embeddings = Path(__file__).parent / "backend" / "data" / "backup" / "animeDBEmbeddings.sql"
        
        success = True
        
        # Restaurar la base de datos principal
        if backup_main.exists():
            print("‚úì Archivo de backup encontrado para la base de datos principal")
            print("‚è≥ Restaurando base de datos principal (puede tardar varios minutos)...")
            
            try:
                # Verificar tama√±o y formato del archivo SQL
                file_size_mb = backup_main.stat().st_size / (1024 * 1024)
                print(f"   - Tama√±o del archivo: {file_size_mb:.2f} MB")
                
                if file_size_mb < 0.1:
                    print("‚ö†Ô∏è El archivo de backup parece estar vac√≠o o es demasiado peque√±o")
                    success = False
                else:
                    # Limpiar el esquema actual
                    subprocess.run(
                        ["powershell.exe", 'docker exec anime_postgres psql -U anime_db -d animeDB -c "DROP SCHEMA IF EXISTS public CASCADE; CREATE SCHEMA public;"'],
                        stdout=subprocess.DEVNULL,
                        stderr=subprocess.PIPE
                    )
                    
                    # Verificar que el archivo SQL est√© disponible dentro del contenedor
                    check_file = subprocess.run(
                        ["powershell.exe", "docker exec anime_postgres ls -la /backup/animeDB.sql"],
                        capture_output=True,
                        text=True
                    )
                    
                    if "No such file or directory" in check_file.stderr:
                        print("‚ùå El archivo de backup no est√° disponible dentro del contenedor")
                        print("   Aseg√∫rate de que el volumen est√° montado correctamente en docker-compose.yml")
                        success = False
                    else:
                        # Restaurar desde backup
                        print("   - Ejecutando restauraci√≥n (psql)...")
                        result = subprocess.run(
                            ["powershell.exe", 'docker exec anime_postgres psql -U anime_db -d animeDB -f /backup/animeDB.sql'],
                            capture_output=True,
                            text=True
                        )
                        
                        if result.returncode == 0:
                            print("‚úÖ Base de datos principal restaurada correctamente")
                        else:
                            print(f"‚ùå Error al restaurar la base de datos principal:")
                            print(f"   {result.stderr.strip()[:200]}...")
                            success = False
                    
            except Exception as e:
                print(f"‚ùå Error al restaurar la base de datos principal: {str(e)}")
                success = False
        else:
            print(f"‚ùå No se encontr√≥ el archivo de backup: {backup_main}")
            success = False
              # Restaurar la base de datos de embeddings
        if backup_embeddings.exists():
            print("\n‚úì Archivo de backup encontrado para la base de datos de embeddings")
            print("‚è≥ Restaurando base de datos de embeddings (puede tardar varios minutos)...")
            
            try:
                # Verificar tama√±o y formato del archivo SQL
                file_size_mb = backup_embeddings.stat().st_size / (1024 * 1024)
                print(f"   - Tama√±o del archivo: {file_size_mb:.2f} MB")
                
                if file_size_mb < 0.1:
                    print("‚ö†Ô∏è El archivo de backup parece estar vac√≠o o es demasiado peque√±o")
                    print("   Se proceder√° a crear una estructura vac√≠a")
                    will_create_structure = True
                else:                    # Verificar si el archivo tiene contenido v√°lido
                    print("   - Verificando formato del archivo SQL...")
                    valid_content = False
                    try:
                        with open(backup_embeddings, 'r', encoding='utf-8', errors='ignore') as f:
                            content_sample = f.read(1000)
                            if "CREATE TABLE" in content_sample or "INSERT INTO" in content_sample:
                                valid_content = True
                            elif content_sample.strip() == "" or "PDO::query(): Argument #1" in content_sample:
                                print("‚ö†Ô∏è El archivo SQL est√° vac√≠o o contiene errores")
                                will_create_structure = True
                                
                                # Intentar reparar el archivo SQL
                                print("\nüîÑ Se detectaron problemas en el archivo SQL de embeddings")
                                repair_response = input("¬øIntentar reparar autom√°ticamente el archivo? (s/n): ")
                                if repair_response.lower() in ['s', 'si', 's√≠', 'y', 'yes']:
                                    if attempt_sql_repair(backup_embeddings):
                                        print("‚úÖ Archivo reparado, intentando restaurar nuevamente...")
                                        valid_content = True
                                        will_create_structure = False
                    except Exception as e:
                        print(f"‚ö†Ô∏è No se pudo leer el archivo SQL: {str(e)}")
                        will_create_structure = True
                
                # Limpiar el esquema actual
                print("   - Limpiando esquema existente...")
                subprocess.run(
                    ["powershell.exe", 'docker exec anime_postgres_embeddings psql -U anime_db -d animeDBEmbeddings -c "DROP SCHEMA IF EXISTS public CASCADE; CREATE SCHEMA public;"'],
                    stdout=subprocess.DEVNULL,
                    stderr=subprocess.DEVNULL
                )
                
                # Verificar que el archivo SQL est√© disponible dentro del contenedor
                check_file = subprocess.run(
                    ["powershell.exe", "docker exec anime_postgres_embeddings ls -la /backup/animeDBEmbeddings.sql"],
                    capture_output=True,
                    text=True
                )
                
                if "No such file or directory" in check_file.stderr:
                    print("‚ùå El archivo de backup no est√° disponible dentro del contenedor")
                    print("   Revisa la configuraci√≥n del volumen en docker-compose.yml:")
                    print("   Debe contener una l√≠nea como:")
                    print("   volumes:")
                    print("     - ../backup:/backup")
                    will_create_structure = True
                elif not valid_content and file_size_mb >= 0.1:
                    print("‚ö†Ô∏è El archivo SQL existe pero podr√≠a no tener un formato v√°lido")
                    will_create_structure = True
                
                # Crear estructura m√≠nima para la DB de embeddings
                print("   - Creando estructura b√°sica de tablas...")
                create_table_result = subprocess.run(
                    ["powershell.exe", '''docker exec anime_postgres_embeddings psql -U anime_db -d animeDBEmbeddings -c "
                    CREATE TABLE IF NOT EXISTS anime_unified_embeddings (
                        id SERIAL PRIMARY KEY,
                        anime_id INTEGER NOT NULL,
                        embedding FLOAT[] NOT NULL
                    );"'''],
                    capture_output=True,
                    text=True
                )
                
                if create_table_result.returncode != 0:
                    print("‚ùå Error al crear la estructura b√°sica de tablas:")
                    print(create_table_result.stderr)
                    success = False
                else:
                    print("‚úÖ Estructura b√°sica creada correctamente")
                
                # Intentar restaurar desde backup solo si el archivo parece v√°lido
                if valid_content and not will_create_structure:
                    print("   - Ejecutando restauraci√≥n desde backup...")
                    result = subprocess.run(
                        ["powershell.exe", 'docker exec anime_postgres_embeddings psql -U anime_db -d animeDBEmbeddings -f /backup/animeDBEmbeddings.sql'],
                        capture_output=True,
                        text=True
                    )
                    
                    if result.returncode == 0:
                        print("‚úÖ Base de datos de embeddings restaurada correctamente")
                        
                        # Verificar si realmente se importaron datos
                        check_data = subprocess.run(
                            ["powershell.exe", '''docker exec anime_postgres_embeddings psql -U anime_db -d animeDBEmbeddings -t -c "SELECT COUNT(*) FROM anime_unified_embeddings;"'''],
                            capture_output=True,
                            text=True
                        )
                        
                        if check_data.returncode == 0 and check_data.stdout.strip() and int(check_data.stdout.strip()) > 0:
                            print(f"   - Se importaron {check_data.stdout.strip()} registros de embeddings")
                        else:
                            print("‚ö†Ô∏è Se cre√≥ la estructura pero no se importaron datos")
                            will_create_structure = True
                    else:
                        print(f"‚ùå Error al restaurar la base de datos de embeddings:")
                        print(f"   {result.stderr.strip()[:200]}...")
                        will_create_structure = True
                
                # Si no se pudieron importar datos, ofrecer alternativa
                if will_create_structure:
                    print("\nüîÑ Implementando soluci√≥n alternativa para embeddings...")
                    print("   - Se ha creado una estructura b√°sica de tablas vac√≠a")
                    print("   - Para generar los embeddings, necesitar√°s ejecutar manualmente:")
                    print("     python backend/AI/generate-save-embeddings/generate_improved_embeddings.py")
                    print("     (despu√©s de que el sistema est√© en funcionamiento y la DB principal tenga datos)")
                    
                    # Verificar que la tabla est√© accesible
                    check_access = subprocess.run(
                        ["powershell.exe", '''docker exec anime_postgres_embeddings psql -U anime_db -d animeDBEmbeddings -c "SELECT to_regclass('public.anime_unified_embeddings');"'''],
                        capture_output=True,
                        text=True
                    )
                    
                    if check_access.returncode == 0 and "anime_unified_embeddings" in check_access.stdout:
                        print("‚úÖ Base de datos de embeddings preparada (vac√≠a) y lista para usar")
                    else:
                        print("‚ùå No se pudo configurar correctamente la base de datos de embeddings")
                        success = False
                    
            except Exception as e:
                print(f"‚ùå Error al restaurar la base de datos de embeddings: {str(e)}")
                success = False
        else:
            print(f"‚ùå No se encontr√≥ el archivo de backup: {backup_embeddings}")
            success = False
            
        return success
    except Exception as e:
        print(f"‚ùå Error general al restaurar las bases de datos: {str(e)}")
        return False

def check_database_status():
    """Verifica el estado de las bases de datos y si los datos est√°n cargados"""
    main_db_status = "‚ùì Desconocido"
    main_db_count = 0
    emb_db_status = "‚ùì Desconocido"
    emb_db_count = 0
    
    # Verificar base de datos principal
    try:
        # Verificar si el contenedor est√° en ejecuci√≥n
        container_check = subprocess.run(
            ["powershell.exe", "docker ps -q --filter 'name=anime_postgres'"],
            capture_output=True,
            text=True
        )
        
        if not container_check.stdout.strip():
            main_db_status = "‚ö†Ô∏è Contenedor no activo"
        else:
            # Usar psql para consultar el n√∫mero de registros en la tabla anime
            result = subprocess.run(
                ["powershell.exe", 'docker exec anime_postgres psql -h localhost -p 5432 -U anime_db -d animeDB -t -c "SELECT COUNT(*) FROM anime;"'],
                capture_output=True,
                text=True
            )
            
            if result.returncode == 0:
                count = result.stdout.strip()
                if count and count.isdigit():
                    main_db_count = int(count)
                    if main_db_count > 0:
                        main_db_status = "‚úÖ Activa con datos"
                    else:
                        main_db_status = "‚ÑπÔ∏è Activa sin datos"
                else:
                    main_db_status = "‚ö†Ô∏è Estructura vac√≠a"
            else:
                main_db_status = "‚ö†Ô∏è Error de conexi√≥n"
    except Exception:
        main_db_status = "‚ùå Error"
    
    # Verificar base de datos de embeddings
    try:
        # Verificar si el contenedor est√° en ejecuci√≥n
        container_check = subprocess.run(
            ["powershell.exe", "docker ps -q --filter 'name=anime_postgres_embeddings'"],
            capture_output=True,
            text=True
        )
        
        if not container_check.stdout.strip():
            emb_db_status = "‚ö†Ô∏è Contenedor no activo"
        else:
            # Verificar n√∫mero de embeddings
            emb_result = subprocess.run(
                ["powershell.exe", 'docker exec anime_postgres_embeddings psql -h localhost -p 5432 -U anime_db -d animeDBEmbeddings -t -c "SELECT COUNT(*) FROM anime_unified_embeddings;"'],
                capture_output=True,
                text=True
            )
            
            if emb_result.returncode == 0:
                count = emb_result.stdout.strip()
                if count and count.isdigit():
                    emb_db_count = int(count)
                    if emb_db_count > 0:
                        emb_db_status = "‚úÖ Activa con datos"
                    else:
                        emb_db_status = "‚ÑπÔ∏è Activa sin datos"
                else:
                    # La tabla puede no existir, comprobar
                    table_check = subprocess.run(
                        ["powershell.exe", 'docker exec anime_postgres_embeddings psql -h localhost -p 5432 -U anime_db -d animeDBEmbeddings -t -c "SELECT COUNT(*) FROM pg_tables WHERE tablename = \'anime_unified_embeddings\';"'],
                        capture_output=True,
                        text=True
                    )
                    
                    if table_check.returncode == 0 and table_check.stdout.strip() == "0":
                        emb_db_status = "‚ö†Ô∏è Tabla no encontrada"
                    else:
                        emb_db_status = "‚ö†Ô∏è Estructura vac√≠a"
            else:
                emb_db_status = "‚ö†Ô∏è Error de conexi√≥n"
    except Exception:
        emb_db_status = "‚ùå Error"
    
    # Mostrar resumen
    print("‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print("‚îÇ                   ESTADO DE BASES DE DATOS                  ‚îÇ")
    print("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    print(f"‚îÇ Base de datos principal:    {main_db_status.ljust(40)} ‚îÇ")
    if main_db_count > 0:
        print(f"‚îÇ Animes cargados:           {str(main_db_count).ljust(40)} ‚îÇ")
    print("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    print(f"‚îÇ Base de datos embeddings:   {emb_db_status.ljust(40)} ‚îÇ")
    if emb_db_count > 0:
        print(f"‚îÇ Vectores cargados:          {str(emb_db_count).ljust(40)} ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    
    # Mostrar recomendaci√≥n seg√∫n estado
    if main_db_status != "‚úÖ Activa con datos" or emb_db_status != "‚úÖ Activa con datos":
        print("\n‚ÑπÔ∏è NOTA: Una o ambas bases de datos est√°n vac√≠as o presentan problemas.")
        print("     Algunas funcionalidades del sistema pueden estar limitadas.")

def check_model_exists():
    """Verifica si existen los archivos necesarios del modelo de IA"""
    print("üîÑ Verificando archivos del modelo de IA...")
    
    model_dir = Path(__file__).parent / "model"
    
    required_files = [
        "anime_nn_model.pkl",
        "anime_data.pkl",
        "combined_embeddings.npy",
        "anime_id_to_index.pkl"
    ]
    
    missing_files = []
    for file in required_files:
        file_path = model_dir / file
        if not file_path.exists():
            missing_files.append(file)
    
    if missing_files:
        print("‚ùå Error: No se encontraron los siguientes archivos del modelo:")
        for file in missing_files:
            print(f"  - {file}")
        print("\nDebes obtener estos archivos antes de iniciar el sistema.")
        print("Opciones para obtener el modelo:")
        print("  1. Descarga los archivos del modelo desde el repositorio externo")
        print("  2. Ejecuta el script de entrenamiento para crear un nuevo modelo")
        print("     python backend/AI/trainer/modelKNN.py")
        return False
    
    print("‚úÖ Modelo de IA verificado correctamente")
    return True

def check_docker_compose_config():
    """Verifica que los archivos docker-compose.yml est√©n configurados correctamente para la restauraci√≥n desde backup"""
    print("üîÑ Verificando la configuraci√≥n de Docker Compose...")
    
    # Rutas a los archivos docker-compose.yml
    db_main_path = Path(__file__).parent / "backend" / "data" / "database"
    db_embeddings_path = Path(__file__).parent / "backend" / "data" / "databaseForEmbeddings"
    backup_path = Path(__file__).parent / "backend" / "data" / "backup"
    
    # Verificar que la carpeta de backup exista
    if not backup_path.exists():
        print(f"‚ùå No se encontr√≥ la carpeta de backups: {backup_path}")
        print("   Creando directorio de backup...")
        backup_path.mkdir(parents=True, exist_ok=True)
        print("‚úÖ Directorio de backup creado.")
    
    # Verificar docker-compose.yml de base de datos principal
    if (db_main_path / "docker-compose.yml").exists():
        with open(db_main_path / "docker-compose.yml", "r") as f:
            content = f.read()
            if "/backup:/backup" not in content:
                print("‚ö†Ô∏è La configuraci√≥n de vol√∫menes en docker-compose.yml de la base de datos principal no incluye la carpeta de backup")
                print("   Los backups podr√≠an no ser accesibles desde el contenedor.")
                print("   Se recomienda a√±adir el siguiente volumen en el archivo docker-compose.yml:")
                print("   - ../backup:/backup")
    
    # Verificar docker-compose.yml de base de datos de embeddings
    if (db_embeddings_path / "docker-compose.yml").exists():
        with open(db_embeddings_path / "docker-compose.yml", "r") as f:
            content = f.read()
            if "/backup:/backup" not in content:
                print("‚ö†Ô∏è La configuraci√≥n de vol√∫menes en docker-compose.yml de la base de datos de embeddings no incluye la carpeta de backup")
                print("   Los backups podr√≠an no ser accesibles desde el contenedor.")
                print("   Se recomienda a√±adir el siguiente volumen en el archivo docker-compose.yml:")
                print("   - ../backup:/backup")

def attempt_sql_repair(sql_file_path):
    """Intenta reparar un archivo SQL corrupto o con errores de formato"""
    print(f"üîÑ Intentando reparar archivo SQL: {sql_file_path.name}")
    
    if not sql_file_path.exists():
        print("‚ùå El archivo no existe")
        return False
    
    # Crear un respaldo antes de modificar el archivo
    backup_path = sql_file_path.with_suffix('.sql.bak')
    try:
        import shutil
        shutil.copy2(sql_file_path, backup_path)
        print(f"‚úì Backup creado: {backup_path.name}")
    except Exception as e:
        print(f"‚ö†Ô∏è No se pudo crear backup: {e}")
    
    try:
        # Leer el contenido del archivo
        with open(sql_file_path, 'r', encoding='utf-8', errors='ignore') as f:
            content = f.read()
        
        # Verificar problemas comunes
        if not content.strip():
            print("‚ùå El archivo est√° vac√≠o, no se puede reparar")
            return False
        
        # Eliminar caracteres problem√°ticos al inicio del archivo
        if not content.lstrip().startswith(("--", "/*", "CREATE", "INSERT", "BEGIN", "SET")):
            # Buscar el primer comando SQL v√°lido
            valid_starts = ["--", "/*", "CREATE", "INSERT", "BEGIN", "SET"]
            start_pos = -1
            for marker in valid_starts:
                pos = content.find(marker)
                if pos >= 0 and (start_pos == -1 or pos < start_pos):
                    start_pos = pos
            
            if start_pos > 0:
                print(f"‚úì Eliminando {start_pos} caracteres no v√°lidos al inicio")
                content = content[start_pos:]
        
        # Agregar instrucciones necesarias al inicio si faltan
        if not any(content.lstrip().startswith(prefix) for prefix in ["BEGIN", "SET", "CREATE"]):
            print("‚úì Agregando encabezado SQL est√°ndar")
            header = "-- Archivo SQL reparado autom√°ticamente\n"
            header += "SET client_encoding = 'UTF8';\n"
            header += "BEGIN;\n\n"
            content = header + content
        
        # Asegurar que hay un COMMIT al final si hay BEGIN
        if "BEGIN" in content and "COMMIT" not in content:
            print("‚úì Agregando COMMIT al final del archivo")
            content = content.rstrip() + "\n\nCOMMIT;\n"
        
        # Escribir el contenido reparado
        with open(sql_file_path, 'w', encoding='utf-8') as f:
            f.write(content)
        
        print("‚úÖ Archivo SQL reparado y guardado")
        return True
    
    except Exception as e:
        print(f"‚ùå Error al intentar reparar el archivo: {str(e)}")
        
        # Intentar restaurar desde backup si existe
        if backup_path.exists():
            try:
                import shutil
                shutil.copy2(backup_path, sql_file_path)
                print("‚úì Archivo restaurado desde backup")
            except Exception as e2:
                print(f"‚ùå No se pudo restaurar desde backup: {e2}")
        
        return False

# Eliminamos la funci√≥n install_pgvector_in_containers 
# ya que no es necesaria para el flujo simplificado

# Eliminamos las funciones diagnose_embeddings_db y repair_embeddings_database
# ya que no son necesarias para el flujo simplificado

def main():
    """Funci√≥n principal"""
    print("\n=== S.A.R LAUNCHER - SMART ANIME RECOMMENDER ===\n")
    
    # Inicializar procesos
    processes = {'backend': None, 'frontend': None}
    
    # Manejar se√±ales
    signal.signal(signal.SIGINT, lambda sig, frame: terminate_processes(processes))
    atexit.register(lambda: None if is_terminating.is_set() else terminate_processes(processes))
    
    # Verificar existencia del modelo de IA
    if not check_model_exists():
        print("\n‚ùå ERROR: No se puede iniciar el sistema sin los archivos del modelo de IA")
        input("\nPresiona Enter para salir...")
        return 1
    
    # Men√∫ simplificado con 3 opciones
    print("\n=== OPCIONES DE INICIO ===")
    print("1. Iniciar sistema con bases de datos vac√≠as")
    print("2. Iniciar sistema con datos precargados desde backup")
    print("3. Salir")
    
    while True:
        choice = input("\nSelecciona una opci√≥n (1-3): ").strip()
        
        # Validar la entrada
        if choice not in ["1", "2", "3"]:
            print("‚ùå Opci√≥n no v√°lida. Por favor, selecciona 1, 2 o 3.")
            continue
            
        # Salir inmediatamente si esa fue la opci√≥n elegida
        if choice == "3":
            print("‚úÖ Saliendo del sistema")
            return 0
        
        break  # Salir del bucle si la opci√≥n es v√°lida (1 o 2)
      # Verificar la configuraci√≥n de Docker Compose
    if choice == "2":
        print("\nüîÑ Verificando configuraci√≥n para restauraci√≥n desde backup...")
        check_docker_compose_config()    # Iniciar los contenedores Docker para ambas opciones (1 y 2)
    print("\nüîÑ Iniciando contenedores Docker...")
    if not start_docker_containers():
        print("‚ùå Error al iniciar los contenedores Docker.")
        input("\nPresiona Enter para salir...")
        return 1
    
    # Si la opci√≥n es 2, cargar datos desde backup
    if choice == "2":
        print("\nüîÑ Cargando datos desde archivos de backup...")
        restore_result = restore_databases_from_backup()
        
        if not restore_result:
            print("\n‚ö†Ô∏è No se pudieron restaurar completamente los datos desde backup.")
            print("‚ÑπÔ∏è Es posible que algunas funcionalidades no est√©n disponibles.")
            response = input("\n¬øDeseas continuar con el inicio del sistema de todas formas? (s/n): ")
            if response.lower() not in ['s', 'si', 's√≠', 'y', 'yes']:
                print("‚ùå Inicio del sistema cancelado por el usuario.")
                input("\nPresiona Enter para salir...")
                return 1
    
    # Verificar el estado de las bases de datos para informaci√≥n del usuario
    print("\n=== ESTADO DE LAS BASES DE DATOS ===")
    check_database_status()
    
    # Iniciar el backend y frontend
    print("\n=== INICIANDO SERVICIOS ===")
      # Iniciar backend
    print("üîÑ Iniciando backend (API FastAPI)...")
    processes['backend'] = start_backend()
    if not processes['backend']:
        print("‚ùå Error al iniciar el backend")
        input("\nPresiona Enter para salir...")
        return 1
    
    print("\n‚è≥ Esperando a que el backend est√© listo...")
    time.sleep(5)  # Dar tiempo para que el backend se inicie completamente
    
    # Iniciar frontend
    print("üîÑ Iniciando frontend (React)...")
    processes['frontend'] = start_frontend()
    if not processes['frontend']:
        print("‚ùå Error al iniciar el frontend")
        print("üõë Deteniendo el backend...")
        terminate_processes({'backend': processes['backend']})
        input("\nPresiona Enter para salir...")
        return 1
    
    # Guardar PIDs para recuperaci√≥n
    pid_file = os.path.join(tempfile.gettempdir(), "sar_processes.json")
    with open(pid_file, 'w') as f:
        json.dump({name: process.pid for name, process in processes.items() if process}, f)
    
    # Mostrar resumen final
    print("\n‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê")
    print("‚îÇ                SISTEMA INICIADO CORRECTAMENTE                ‚îÇ")
    print("‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§")
    print("‚îÇ üîπ Backend (API):         http://127.0.0.1:8000             ‚îÇ")
    print("‚îÇ üîπ Frontend (Interfaz):   http://localhost:5173             ‚îÇ")
    print("‚îÇ üîπ Documentaci√≥n API:     http://127.0.0.1:8000/docs        ‚îÇ")
    print("‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò")
    print("\n‚úÖ Todos los servicios est√°n en ejecuci√≥n")
    print("‚úÖ Puedes cerrar esta ventana para detener el sistema (Ctrl+C)")
    
    try:
        # Esperar hasta que un proceso termine o se reciba Ctrl+C
        while all(process.poll() is None for process in processes.values() if process) and not is_terminating.is_set():
            time.sleep(1)
        
        if not is_terminating.is_set():
            print("\n‚ö†Ô∏è Un proceso ha terminado inesperadamente")
            terminate_processes(processes)
            
    except KeyboardInterrupt:
        terminate_processes(processes)
    
    # Dar tiempo para que los mensajes se impriman
    if is_terminating.is_set():
        time.sleep(0.5)
    
    return 0

if __name__ == "__main__":
    sys.exit(main())
